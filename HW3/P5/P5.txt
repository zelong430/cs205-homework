Part 1 implement updates from neighbors
maze1.py:
Finished after 877 iterations, 329.058432 ms total, 0.375209158495 ms per iteration
Found 2 regions

maze2.py:
Finished after 509 iterations, 191.541312 ms total, 0.376309060904 ms per iteration
Found 35 regions
Part 2: fetch grandparents
****************************************************************************
****************************************************************************
maze1.npy:
Finished after 10 iterations, 4.255584 ms total, 0.4255584 ms per iteration
Found 2 regions

maze2.npy:
Finished after 9 iterations, 3.8264 ms total, 0.425155555556 ms per iteration
Found 35 regions

Part 4: efficient grandparents
****************************************************************************
maze1.npy:
Finished after 16 iterations, 10.9162 ms total, 0.6822625 ms per iteration
Found 2 regions

maze2.npy:
Finished after 15 iterations, 10.3614 ms total, 0.0.69076 ms per iteration
Found 35 regions

DISCUSSION:
My empirical results shows that for these two test image, chaning the memory reads from parallel to serial resulting in a performance drop. It is not a reasonable choice to change to serial fetch by only one thread. In our program, the data fetching is fast in GPU. Thus, although we avoid redundat memory reads, the time saved in memory reads is relatively smaller than the time increased by changing parallel computation into serial computation.

If the computing happens in hardware with slow memory access, such as CPU, the time saved by avoiding redundant memory access may become relatively siginifcant compared with the time increased by changing parallel computation into serial computation.  

Part 5: no atomic operations
****************************************************************************
maze1.npy:
Found 2 regions

maze2.npy:
Found 35 regions

DISCUSSION:
From my emprical result, the code run smoothly and the final result was still correct. The performance, ie. number of iteration and time, are also very close. Using atomic_min() function ensure that only one thread could update the label at each time. On the other head, using min() function may cause several threads update on same label and result in a wrong value.  

